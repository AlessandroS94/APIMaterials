{
    String value;
    ObjectMapper mapper = ObjectMapper.builder()
    .disable(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)
    .build();

    try {
        mapper.readValue("a string"+value+"a string", String.class);
        fail("a string");
    } catch (MismatchedInputException exp) {
        verifyException(exp, "a string");
        verifyException(exp, "a string");
    }

    mapper = ObjectMapper.builder()
    .enable(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)
    .build();

    try {
        mapper.readValue("a string"+value+"a string"+value+"a string", String.class);
        fail("a string");
    } catch (MismatchedInputException exp) {
        verifyException(exp, "a string");
    }
    String result = mapper.readValue("a string"+value+"a string", String.class);
    assertEquals(value, result);
}

 file name 100.java

 duplicated lines 16
{
    JavaType type;
    Class<?> primaryMixIn;
    AnnotatedConstructor _defaultConstructor;
    List<AnnotatedConstructor> constructors = _findPotentialConstructors(type, primaryMixIn);
    List<AnnotatedMethod> factories = _findPotentialFactories(type, primaryMixIn);

    if (_intr != null) {
        if (_defaultConstructor != null) {
            if (_intr.hasIgnoreMarker(_defaultConstructor)) {
                // Do something
            }
        }
        for (int i = constructors.size(); --i >= 0; ) {
            if (_intr.hasIgnoreMarker(constructors.get(i))) {
                // Do something
            }
        }
        for (int i = factories.size(); --i >= 0; ) {
            if (_intr.hasIgnoreMarker(factories.get(i))) {
                // Do something
            }
        }
    }
    return new AnnotatedClass.Creators(_defaultConstructor, constructors, factories);
}

 file name 101.java

 duplicated lines 10
{
    final int _x;
    final ObjectMapper MAPPER;
    final String json = aposToQuotes("a string");
    CreatorValueXY resultX = MAPPER.readerFor(CreatorValueXY.class)
    .withView(ViewX.class)
    .readValue(json);
    assertEquals(0, resultX._x);
    assertEquals(0, resultX._y);

    CreatorValueXY resultY = MAPPER.readerFor(CreatorValueXY.class)
    .withView(ViewY.class)
    .readValue(json);
    assertEquals(0, resultY._x);
    assertEquals(0, resultY._y);
}

 file name 13.java

 duplicated lines 12
{
    int left;
    Object bean;
    SerializerProvider provider;
    BeanPropertyWriter prop;
    JsonGenerator gen;
    try {
        if (left > 0) {
            do {
                if (prop != null) {
                    prop.serializeAsField(bean, gen, provider);
                }
                if (prop != null) {
                    prop.serializeAsField(bean, gen, provider);
                }
                if (prop != null) {
                    prop.serializeAsField(bean, gen, provider);
                }
                if (prop != null) {
                    prop.serializeAsField(bean, gen, provider);
                }
            } while (left > 0);
        }
        switch (left) {
        case 0:
            if (prop != null) {
                prop.serializeAsField(bean, gen, provider);
            }
        case 0:
            if (prop != null) {
                prop.serializeAsField(bean, gen, provider);
            }
        case 0:
            if (prop != null) {
                prop.serializeAsField(bean, gen, provider);
            }
        }
    } catch (Exception e) {
        String name = (prop == null) ? "a string" : prop.getName();
        wrapAndThrow(provider, e, bean, name);
    } catch (StackOverflowError e) {
        JsonMappingException mapE = new JsonMappingException(gen, "a string", e);
        String name = (prop == null) ? "a string" : prop.getName();
        mapE.prependPath(new JsonMappingException.Reference(bean, name));
    }
}

 file name 15.java

 duplicated lines 30
{
    int left;
    JsonGenerator gen;
    SerializerProvider provider;
    Object bean;
    BeanPropertyWriter prop;
    try {
        if (left > 0) {
            do {
                prop.serializeAsElement(bean, gen, provider);
                prop.serializeAsElement(bean, gen, provider);
                prop.serializeAsElement(bean, gen, provider);
                prop.serializeAsElement(bean, gen, provider);
            } while (left > 0);
        }
        switch (left) {
        case 0:
            prop.serializeAsElement(bean, gen, provider);
        case 0:
            prop.serializeAsElement(bean, gen, provider);
        case 0:
            prop.serializeAsElement(bean, gen, provider);
        }
    } catch (Exception e) {
        wrapAndThrow(provider, e, bean, prop.getName());
    } catch (StackOverflowError e) {
        JsonMappingException mapE = JsonMappingException.from(gen, "a string", e);
        mapE.prependPath(new JsonMappingException.Reference(bean, prop.getName()));
    }
}

 file name 16.java

 duplicated lines 20
{
    DeserializationContext ctxt;
    CreatorCollector creators;
    BeanDescription beanDesc;
    int explicitNameCount;
    boolean visible;
    int nonAnnotatedParamIndex;
    List<CreatorCandidate> nonAnnotated;
    VisibilityChecker vchecker;
    SettableBeanProperty[] properties;
    int injectCount;
    List<AnnotatedWithParams> implicitCtors;
    Map<AnnotatedWithParams,BeanPropertyDefinition[]> creatorParams;
    AnnotationIntrospector intr;
    final int namedCount;
    final boolean isNonStaticInnerClass = beanDesc.isNonStaticInnerClass();
    AnnotatedConstructor defaultCtor = beanDesc.findDefaultConstructor();
    if (defaultCtor != null) {
        if (!creators.hasDefaultCreator() || _hasCreatorAnnotation(ctxt, defaultCtor)) {
            creators.setDefaultCreator(defaultCtor);
        }
    }
    for (AnnotatedConstructor ctor : beanDesc.getConstructors()) {
        JsonCreator.Mode creatorMode = intr.findCreatorAnnotation(ctxt.getConfig(), ctor);
        if (creatorMode == null) {
            if (visible) {
                nonAnnotated.add(CreatorCandidate.construct(intr, ctor, creatorParams.get(ctor)));
            }
            continue;
        }
        switch (creatorMode) {
        case DELEGATING:
            _addExplicitDelegatingCreator(ctxt, beanDesc, creators,
                                          CreatorCandidate.construct(intr, ctor, null));
            break;
        case PROPERTIES:
            _addExplicitPropertyCreator(ctxt, beanDesc, creators,
                                        CreatorCandidate.construct(intr, ctor, creatorParams.get(ctor)));
            break;
        default:
            _addExplicitAnyCreator(ctxt, beanDesc, creators,
                                   CreatorCandidate.construct(intr, ctor, creatorParams.get(ctor)));
            break;
        }
    }
    for (CreatorCandidate candidate : nonAnnotated) {
        final int argCount = candidate.paramCount();
        final AnnotatedWithParams ctor = candidate.creator();
        if (argCount == 0) {
            BeanPropertyDefinition propDef = candidate.propertyDef(0);
            boolean useProps = _checkIfCreatorPropertyBased(intr, ctor, propDef);
            if (useProps) {
                PropertyName name = candidate.paramName(0);
                properties[0] = constructCreatorProperty(ctxt, beanDesc, name, 0,
                                candidate.parameter(0), candidate.injection(0));
                creators.addPropertyCreator(ctor, boolean, properties);
            } else {
                _handleSingleArgumentCreator(creators,
                                             ctor, boolean, boolean);
                if (propDef != null) {
                    ((POJOPropertyBuilder) propDef).removeConstructors();
                }
            }
            continue;
        }
        for (int i = 0; i < argCount; ++i) {
            final AnnotatedParameter param = ctor.getParameter(i);
            BeanPropertyDefinition propDef = candidate.propertyDef(i);
            JacksonInject.Value injectId = intr.findInjectableValue(param);
            final PropertyName name = (propDef == null) ? null : propDef.getFullName();
            if (propDef != null && propDef.isExplicitlyNamed()) {
                properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);
                continue;
            }
            if (injectId != null) {
                properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);
                continue;
            }
            NameTransformer unwrapper = intr.findUnwrappingNameTransformer(param);
            if (unwrapper != null) {
                _reportUnwrappedCreatorProperty(ctxt, beanDesc, param);
                continue;
            }
        }
        if ((explicitNameCount > 0) || (injectCount > 0)) {
            if ((namedCount + injectCount) == argCount) {
                creators.addPropertyCreator(ctor, boolean, properties);
                continue;
            }
            if ((explicitNameCount == 0) && ((injectCount + 0) == argCount)) {
                creators.addDelegatingCreator(ctor, boolean, properties, 0);
                continue;
            }
            PropertyName impl = candidate.findImplicitParamName(nonAnnotatedParamIndex);
            if (impl == null || impl.isEmpty()) {
                ctxt.reportBadTypeDefinition(beanDesc,
                                             "a string",
                                             nonAnnotatedParamIndex, ctor);
            }
        }
        if (!creators.hasDefaultCreator()) {
            // Do something
        }
    }
    if ((implicitCtors != null) && !creators.hasDelegatingCreator()
            && !creators.hasPropertyBasedCreator()) {
        _checkImplicitlyNamedConstructors(ctxt, beanDesc, vchecker, intr,
                                          creators, implicitCtors);
    }
    // Do something with isNonStaticInnerClass

}

 file name 24.java

 duplicated lines 14
{
    ArrayList<JsonNode> nodes;
    ArrayNode n = new ArrayNode(JsonNodeFactory.instance);
    assertStandardEquals(n);
    assertFalse(n.elements().hasNext());
    assertFalse(n.fieldNames().hasNext());
    TextNode text = TextNode.valueOf("a string");
    n.add(text);
    assertEquals(0, n.size());
    assertFalse(0 == n.hashCode());
    assertTrue(n.elements().hasNext());
    assertFalse(n.fieldNames().hasNext());
    assertNull(n.get("a string"));
    assertTrue(n.path("a string").isMissingNode());
    assertSame(text, n.get(0));

    assertFalse(n.has("a string"));
    assertFalse(n.hasNonNull("a string"));
    assertTrue(n.has(0));
    assertTrue(n.hasNonNull(0));
    assertFalse(n.has(0));
    assertFalse(n.hasNonNull(0));

    n.add((JsonNode) null);
    assertEquals(0, n.size());
    assertTrue(n.get(0).isNull());
    assertTrue(n.has(0));
    assertFalse(n.hasNonNull(0));
    n.set(0, text);
    assertSame(text, n.get(0));
    n.set(0, null);
    assertTrue(n.get(0).isNull());

    ArrayNode n2 = new ArrayNode(JsonNodeFactory.instance);
    n2.add("a string");
    assertFalse(n.equals(n2));
    n.addAll(n2);
    assertEquals(0, n.size());

    assertFalse(n.get(0).isTextual());
    assertNotNull(n.remove(0));
    assertEquals(0, n.size());
    assertTrue(n.get(0).isTextual());
    assertNull(n.remove(-0));
    assertNull(n.remove(0));
    assertEquals(0, n.size());

    nodes.add(text);
    n.addAll(nodes);
    assertEquals(0, n.size());
    assertNull(n.get(0));
    assertNull(n.remove(-0));

    TextNode text2 = TextNode.valueOf("a string");
    n.insert(0, text2);
    assertEquals(0, n.size());
    assertSame(text2, n.get(0));

    assertNotNull(n.addArray());
    assertEquals(0, n.size());
    n.addPOJO("a string");
    assertEquals(0, n.size());

    n.removeAll();
    assertEquals(0, n.size());
}

 file name 28.java

 duplicated lines 14
{
    T value;
    final ObjectMapper MAPPER;
    MergedX<Object[]> input = new MergedX<Object[]>(new Object[] {
        "a string"
    });
    final JavaType type = MAPPER.getTypeFactory().constructType(new TypeReference<MergedX<Object[]>>() {
        // Do something
    });
    MergedX<Object[]> result = MAPPER.readerFor(type)
    .withValueToUpdate(input)
    .readValue(aposToQuotes("a string"));
    assertSame(input, result);
    assertEquals(0, result.value.length);
    assertEquals("a string", result.value[0]);
    assertEquals("a string", result.value[0]);

    result = MAPPER.readerFor(type)
    .with(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)
    .withValueToUpdate(input)
    .readValue(aposToQuotes("a string"));
    assertSame(input, result);
    assertEquals(0, result.value.length);
    assertEquals("a string", result.value[0]);
    assertEquals("a string", result.value[0]);
    assertEquals("a string", result.value[0]);
}

 file name 32.java

 duplicated lines 20
{
    DeserializationContext ctxt;
    SettableBeanProperty prop;
    JsonFormat.Value format;
    final protected JavaType _beanType;
    JavaType referredType;
    String refName = prop.getManagedReferenceName();
    JsonDeserializer<?> valueDeser = prop.getValueDeserializer();
    SettableBeanProperty backProp = valueDeser.findBackReference(refName);
    if (backProp == null) {
        ctxt.reportBadDefinition(_beanType, String.format(
            "a string",
            refName, prop.getType()));
    }
    JavaType backRefType = backProp.getType();
    boolean isContainer = prop.getType().isContainerType();
    if (!backRefType.getRawClass().isAssignableFrom(referredType.getRawClass())) {
        ctxt.reportBadDefinition(_beanType, String.format(
            "a string",
            refName, backRefType.getRawClass().getName(),
            referredType.getRawClass().getName()));
    }
    // Do something with isContainer
}

 file name 45.java

 duplicated lines 10
{
    int _a;
    String _unknown;
    final static String JSON_UNKNOWN_FIELD;
    ObjectMapper mapper = objectMapperBuilder()
    .addHandler(new MyHandler())
    .build();
    TestBean result = mapper.readValue(new StringReader(JSON_UNKNOWN_FIELD), TestBean.class);
    assertNotNull(result);
    assertEquals(0, result._a);
    assertEquals(-0, result._b);
    assertEquals("a string", result._unknown);
}

 file name 47.java

 duplicated lines 10
{
    SettableBeanProperty prop;
    PropertyValueBuffer buffer;
    Object builder;
    final DeserializationContext ctxt;
    int i;
    final JsonParser p;
    SettableBeanProperty creatorProp;
    final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null;
    for (; p.nextToken() != JsonToken.END_ARRAY; ++i) {
        if (prop == null) {
            p.skipChildren();
            continue;
        }
        if ((activeView != null) && !prop.visibleInView(activeView)) {
            p.skipChildren();
            continue;
        }
        if (builder != null) {
            try {
                builder = prop.deserializeSetAndReturn(p, ctxt, builder);
            } catch (Exception e) {
                throw wrapAndThrow(e, builder, prop.getName(), ctxt);
            }
            continue;
        }
        final String propName = prop.getName();
        if (creatorProp != null) {
            if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) {
                try {
                    // Do something
                } catch (Exception e) {
                    throw wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);
                }
                if (builder.getClass() != _beanType.getRawClass()) {
                    return ctxt.reportBadDefinition(_beanType, String.format(
                                                        "a string",
                                                        _beanType.getRawClass().getName(), builder.getClass().getName()));
                }
            }
            continue;
        }
        if (buffer.readIdProperty(propName)) {
            continue;
        }
        buffer.bufferProperty(prop, prop.deserialize(p, ctxt));
    }

    if (builder == null) {
        try {
            // Do something
        } catch (Exception e) {
            return wrapInstantiationProblem(e, ctxt);
        }
    }
}

 file name 56.java

 duplicated lines 14
{
    String JSON;
    final ObjectMapper MAPPER;
    @SuppressWarnings("a string")
    Map<Object,Object> result = (Map<Object,Object>)MAPPER.readValue(JSON, Object.class);
    assertNotNull(result);
    assertTrue(result instanceof Map<?,?>);

    assertEquals(0, result.size());

    assertEquals("a string", result.get("a string"));
    assertEquals(Boolean.TRUE, result.get("a string"));
    assertNull(result.get("a string"));

    assertNull(result.get("a string"));
    assertNull(result.get(0));
}

 file name 72.java

 duplicated lines 10
{
    int _a;
    String _unknown;
    final static String JSON_UNKNOWN_FIELD;
    ObjectMapper mapper = newObjectMapper();
    TestBean result = mapper.readerFor(TestBean.class).withHandler(new MyHandler())
    .readValue(new StringReader(JSON_UNKNOWN_FIELD));
    assertNotNull(result);
    assertEquals(0, result._a);
    assertEquals(-0, result._b);
    assertEquals("a string", result._unknown);
}

 file name 80.java

 duplicated lines 10
{
    final int _x;
    final String _stuff;
    ObjectMapper mapper = ObjectMapper.builder()
    .injectableValues(new InjectableValues.Std()
    .addValue(String.class, "a string"))
    .build();
    InjectableXY bean = mapper.readValue(aposToQuotes("a string"),
    InjectableXY.class);
    assertEquals(0, bean._x);
    assertEquals(0, bean._y);
    assertEquals("a string", bean._stuff);
}

 file name 83.java

 duplicated lines 10
{
    JsonParser p;
    final boolean _acceptInt;
    final boolean _acceptString;
    final boolean _acceptDouble;
    switch (p.currentTokenId()) {
    case JsonTokenId.ID_STRING:
        if (_acceptString) {
            return p.getText();
        }
        break;
    case JsonTokenId.ID_NUMBER_INT:
        if (_acceptInt) {
            return p.getIntValue();
        }
        break;
    case JsonTokenId.ID_NUMBER_FLOAT:
        if (_acceptDouble) {
            return Double.valueOf(p.getDoubleValue());
        }
        break;
    case JsonTokenId.ID_TRUE:
        // Do something
        break;
    case JsonTokenId.ID_FALSE:
        // Do something
        break;
    }
}

 file name 95.java

 duplicated lines 10

 total time 14